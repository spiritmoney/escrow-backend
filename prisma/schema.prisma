generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String               @id @default(cuid()) @db.VarChar(16)
  email                String               @unique
  password             String
  firstName            String
  lastName             String
  country              String
  organisation         String
  walletAddress        String?              @unique
  role                 UserRole             @default(DEVELOPER)
  isVerified           Boolean              @default(false)
  otp                  String?
  otpExpiry            DateTime?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  balance              Balance?
  wallet               Wallet?
  sentTransactions     Transaction[]        @relation("SentTransactions")
  receivedTransactions Transaction[]        @relation("ReceivedTransactions")
  paymentRequests      PaymentRequest[]
  paymentLinks         PaymentLink[]
  paymentLinkSettings  PaymentLinkSettings?
  initiatedDisputes    Dispute[]            @relation("DisputeInitiator")
  resolvedDisputes     Dispute[]            @relation("DisputeResolver")
  subscriptions        Subscription[]
  paymentMethods       PaymentMethod[]
  autoPaymentSettings  AutoPaymentSettings?
  billingHistory       BillingHistory[]
  phone                String?
  photoUrl             String?
  twoFactorEnabled     Boolean              @default(false)
  twoFactorSecret      String?
  apiSettings          ApiSettings?
  kycVerification      KycVerification?
  supportTickets       SupportTicket[]
  chatSessions         ChatSession[]
  cryptoReservations   CryptoBalanceReservation[]
  custodialWallets    CustodialWallet[]

  @@map("users")
}

enum UserRole {
  BUSINESS
  DEVELOPER
}

model Balance {
  id        String   @id @default(cuid())
  userId    String   @unique
  ngn       Float    @default(0)
  usd       Float    @default(0)
  eur       Float    @default(0)
  esp       Float    @default(0)
  user      User     @relation(fields: [userId], references: [id])
  updatedAt DateTime @updatedAt

  @@map("balances")
}

model Transaction {
  id                String      @id @default(cuid())
  senderId          String
  recipientId       String?
  recipientWallet   String?
  customerId        String
  customer          Customer    @relation(fields: [customerId], references: [id])
  amount            Float
  currency          String
  type              String
  status            String      @default("PENDING")
  note              String?
  txHash            String?
  chainId           Int?
  tokenAddress      String?
  escrowAddress     String?
  originalAmount    Float?
  originalCurrency  String?
  paymentMethod     String?
  paymentDetails    Json?
  paymentConfirmed  Boolean     @default(false)
  buyerConfirmed    Boolean     @default(false)
  sellerConfirmed   Boolean     @default(false)
  createdAt         DateTime    @default(now())
  expiresAt         DateTime?
  data              Json?
  method            String?
  verificationState String?     @default("INITIATED")
  milestones        Milestone[]
  sender            User        @relation("SentTransactions", fields: [senderId], references: [id])
  recipient         User?       @relation("ReceivedTransactions", fields: [recipientId], references: [id])
  disputes          Dispute[]

  @@map("transactions")
}

model PaymentRequest {
  id          String   @id @default(cuid())
  requesterId String
  payerEmail  String
  amount      Float
  currency    String
  description String
  status      String // 'PENDING', 'PAID', 'CANCELLED'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  requester   User     @relation(fields: [requesterId], references: [id])

  @@map("payment_requests")
}

model Wallet {
  id                  String   @id @default(cuid())
  userId              String   @unique
  address             String   @unique
  encryptedPrivateKey String
  iv                  String
  network             String
  type                String
  chainId             Int
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [userId], references: [id])

  @@unique([userId, network])
}

model PaymentLink {
  id                String              @id @default(cuid())
  name              String
  url               String
  type              String              // BUYING or SELLING
  transactionType   String              // CRYPTOCURRENCY, PHYSICAL_GOODS, etc.
  status            String              @default("ACTIVE")
  defaultAmount     Float?
  defaultCurrency   String?
  details           Json?               // Stores the cryptocurrency or other details
  verificationMethod String?
  userId            String
  createdBy         User               @relation(fields: [userId], references: [id])
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  expiresAt         DateTime?
  paymentLinkMethods PaymentLinkMethod[]

  @@map("payment_links")
}

model PaymentLinkMethod {
  id            String      @id @default(uuid())
  paymentLinkId String
  methodId      String
  type          String
  isDefault     Boolean     @default(false)
  details       Json
  paymentLink   PaymentLink @relation(fields: [paymentLinkId], references: [id], onDelete: Cascade)

  @@index([paymentLinkId])
}

model PaymentLinkSettings {
  id                    String   @id @default(cuid())
  userId                String   @unique
  user                  User     @relation(fields: [userId], references: [id])
  defaultCurrency       String   @default("USD")
  defaultExpirationTime Int      @default(24)
  updatedAt             DateTime @updatedAt

  @@map("payment_link_settings")
}

model Dispute {
  id              String      @id @default(cuid())
  transactionId   String
  transaction     Transaction @relation(fields: [transactionId], references: [id])
  initiatorId     String
  initiator       User        @relation("DisputeInitiator", fields: [initiatorId], references: [id])
  resolverId      String?
  resolver        User?       @relation("DisputeResolver", fields: [resolverId], references: [id])
  status          String
  reason          String
  evidence        String[]
  resolutionNotes String?
  createdAt       DateTime    @default(now())
  resolvedAt      DateTime?
  updatedAt       DateTime    @updatedAt

  @@map("disputes")
}

model PaymentMethod {
  id        String   @id @default(cuid())
  userId    String
  type      String // 'CARD' or 'BANK_TRANSFER'
  details   Json
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@map("payment_methods")
}

model AutoPaymentSettings {
  id                       String   @id @default(cuid())
  userId                   String   @unique
  autoRenewSubscription    Boolean  @default(false)
  sendPaymentNotifications Boolean  @default(true)
  updatedAt                DateTime @updatedAt
  user                     User     @relation(fields: [userId], references: [id])

  @@map("auto_payment_settings")
}

model BillingHistory {
  id             String       @id @default(cuid())
  userId         String
  subscriptionId String
  billingDate    DateTime
  amount         Float
  currency       String
  status         String // 'PAID', 'PENDING', 'FAILED'
  paymentMethod  Json?
  user           User         @relation(fields: [userId], references: [id])
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])

  @@map("billing_history")
}

model Subscription {
  id             String             @id @default(cuid())
  userId         String             @unique
  planType       String             @default("STARTER")
  isActive       Boolean            @default(true)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  user           User               @relation(fields: [userId], references: [id])
  usage          SubscriptionUsage?
  billingHistory BillingHistory[]

  @@map("subscriptions")
}

model SubscriptionUsage {
  id                  String       @id @default(cuid())
  subscriptionId      String       @unique
  monthlyTransactions Int          @default(0)
  apiCalls            Int          @default(0)
  monthlyPaymentLinks Int          @default(0)
  lastResetDate       DateTime     @default(now())
  subscription        Subscription @relation(fields: [subscriptionId], references: [id])

  @@map("subscription_usage")
}

model ApiSettings {
  id                   String   @id @default(cuid())
  userId               String   @unique
  user                 User     @relation(fields: [userId], references: [id])
  apiKey               String?
  apiAccess            Boolean  @default(false)
  webhookNotifications Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

model KycVerification {
  id                 String   @id @default(cuid())
  userId             String   @unique
  user               User     @relation(fields: [userId], references: [id])
  level              String   @default("Level 1")
  transactionLimit   Float    @default(1000)
  verificationStatus String   @default("PENDING")
  documents          Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model SupportTicket {
  id           String   @id @default(cuid())
  ticketNumber String   @unique
  subject      String
  message      String
  status       String   @default("OPEN")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  userId       String
  user         User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
}

model ChatSession {
  id             String        @id @default(cuid())
  userId         String
  user           User          @relation(fields: [userId], references: [id])
  topic          String
  status         String // 'WAITING', 'ACTIVE', 'CLOSED'
  initialMessage String?
  messages       ChatMessage[]
  createdAt      DateTime      @default(now())
  endedAt        DateTime?
  updatedAt      DateTime      @updatedAt

  @@index([userId])
  @@index([status])
  @@map("chat_sessions")
}

model ChatMessage {
  id        String      @id @default(cuid())
  sessionId String
  session   ChatSession @relation(fields: [sessionId], references: [id])
  content   String
  sender    String // 'USER' or 'AGENT'
  createdAt DateTime    @default(now())

  @@index([sessionId])
  @@map("chat_messages")
}

model Milestone {
  id            String      @id @default(cuid())
  transactionId String
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  description   String
  amount        Float
  order         Int
  status        String
  completedAt   DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@map("milestones")
}

enum VerificationStatus {
  INITIATED
  PENDING_DELIVERY
  PROOF_SUBMITTED
  PENDING_DOWNLOAD
  AWAITING_CONFIRMATIONS
  COMPLETED
  FAILED
}

enum VerificationMethod {
  LOGISTICS_API
  PROOF_BASED
  SMS_EMAIL
  MILESTONE_BASED
  TWO_WAY_CONFIRMATION
  SECURE_DELIVERY
  BLOCKCHAIN_ESCROW
  MANUAL_HASH
}

model Customer {
  id            String        @id @default(uuid())
  email         String        @unique
  name          String?
  transactions  Transaction[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model CryptoBalanceReservation {
  id           String   @id @default(cuid())
  userId       String
  tokenAddress String
  chainId      Int
  amount       Float
  status       String   // RESERVED, RELEASED, USED
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id])

  @@unique([userId, tokenAddress, chainId])
  @@index([status])
}

model CustodialWallet {
  id            String   @id @default(cuid())
  userId        String
  token         String
  chainId       Int
  network       String
  type          String   @default("CUSTODIAL")
  status        String   @default("ACTIVE")
  balance       String   @default("0")
  address       String?
  tokenDecimals Int      @default(18)
  lastUpdated   DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id])
  balanceHistory CustodialBalanceHistory[]

  @@unique([userId, token, chainId])
  @@map("custodial_wallets")
}

model CustodialBalanceHistory {
  id        String   @id @default(cuid())
  walletId  String
  amount    String
  type      String
  timestamp DateTime @default(now())

  wallet    CustodialWallet @relation(fields: [walletId], references: [id])

  @@map("custodial_balance_history")
}

model BridgeTransaction {
  id              String   @id @default(cuid())
  sourceToken     String
  sourceChainId   Int
  targetToken     String
  targetChainId   Int
  amount          String
  userAddress     String
  status          String
  txHash          String?
  targetTxHash    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("bridge_transactions")
}
